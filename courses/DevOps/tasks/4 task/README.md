# Практическое задание 4

## Дано

Пример **docker-compose.yml** с двумя экземплярами приложения и сервисом **Redis**

## Задание

Сделать новый **docker-compose.yml** для своего сервиса , либо “довести до ума” данный в примере до полноценного вида. Обязательные требования:

- Добавить **Redis** в ту же docker-сеть, в которой находится **RabbitMQ**
- Сделать данные **Redis** персистентными
- Параметризировать время “жизни” кеша **Redis** (`REDIS_CACHE_TIME`)
- `healthcheck` для сервиса Redis (можно посмотреть в сторону утилиты `redis-cli`)
- Доработать `depends_on`, чтобы было аналогично **RabbitMQ,** для основного приложения. Зависимостью между **RabbitMQ** и **Redis** можно пренебречь
- \*Отдельный сервис (контейнер), который раз в минуту будет стучаться на */healthy* приложения (любого из двух или обоих), и “падать”, если получит в ответ код 503
- \*Сделать резервирование: если rmq не работает, коммуникацию подхватит redis, и наоборот

## Проверка результата


- Сделать POST-запрос с любым содержимым на **localhost:8001/redis-send**
- Сделать GET-запрос на **localhost:8002/redis-get** и убедиться, что сообщение получено
- Сделать дважды GET-запрос на **localhost:8001/calculate** и убедиться, что кеширование работает: первый раз долго “думает”, второй раз возращает быстро с пометкой *from_cache=true*
- Стукнуться на localhost:8001/healthy (или 8002) и проверить, что там ожидаемый json и `200 OK`
- Выполнить `docker ps` и убедиться, что сервис redis не только *up*, но и *healthy*

## Отчетность

- docker-compose.yml
- Код приложения, если он отличается от примера по умолчанию