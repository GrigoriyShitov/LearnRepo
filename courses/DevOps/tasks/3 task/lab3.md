# Практическое задание 3

## Дано

Пример **docker-compose.yml** с двумя экземплярами приложения и сервисом **RabbitMQ**

## Задание

Сделать новый **docker-compose.yml** для своего сервиса , либо “довести до ума” данный в примере до полноценного вида. Обязательные требования: все из Практического задания 2, плюс:

- сделать, чтоб с точки зрения сети оба экземпляра приложения видели сервер **RabbitMQ**, *но не видели друг друга*
- Монтирование данных для сервиса rmq (его системная директория, его конфиг, или что-то аналогичное)
- `healthcheck` для сервиса rmq (можно посмотреть в сторону утилиты `rabbitmq-diagnostics`)
- Доработать `depends_on`, добавив условие, что зависимый сервис = *healthy*
- Вынести "креды" rmq из композ файла (`.env`)
- \*Дополнительно: сделать, чтоб у каждого экземпляра сервиса была собственная очередь
- \*Дополнительно: сделать, чтоб при обращении к эндпоинту считывались *сразу все* сообщения, накопленные в очереди

## Проверка результата

- Сделать POST-запрос с любым содержимым на **localhost:8001/rmq-send**
- Сделать GET-запрос на **localhost:8002/rmq-get** и убедиться, что сообщение получено
- Стукнуться на localhost:8001/healthy (или 8002) и проверить, что там ожидаемый json и `200 OK`
- Выполнить `docker ps` и убедиться, что сервис rmq не только *up*, но и *healthy*

## Отчетность

- `docker-compose.yml`
- Код приложения, если он отличается от примера по умолчанию